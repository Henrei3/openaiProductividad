from backend.Model.DB.Connexion import Connexion
from pyodbc import ProgrammingError


class SQLSERVERDBModel:
    """ This class connects directly to the SQLServer database, it connects to the rest of the application
     with the help of the class PostGreController"""

    def __init__(self):
        self.cursor = Connexion().cursor()

    def get_all_successfull_recordings_given_date(self, y: str, m: str, d: str):
        """ Method used for the embedding calculation part of the application. It returns only the operation that have
        achieved a debt payment"""
        return self.test(y, m, d)

    def get_all_recordings_given_date(self, y: str, m: str, d: str):
        """ Method used for the score calculation part of the application
        it returns all the arrangements done in certain date """

        requete = f"select top 20 id_gestion, accion_ges, respuesta_ges, telefono_ges, fecha_ges, cedente, serial_ced from CEDENTE a inner join GESTIONES b  on a.nombre_ced=b.cedente where tipo_ges = 1 and convert(date,fecha_ges,120)=convert(date,'{y}-{m}-{d}',120)"
        self.cursor.execute(
            requete
        )
        return self.cursor.fetchall()

    def get_serialced_from_cedente(self, name: str):

        requete = """select * from CEDENTE where nombre_ced= ? """
        self.cursor.execute(requete, name)
        return self.cursor.fetchone()

    def get_positive_sentences(self, serial_ced: str):
        requete = "select * from CCALIDAD_FRASE where serial_ced= ? and tipo_ccf='ACTIVO' order by etiqueta_ccf"
        self.cursor.execute(requete, serial_ced)
        return self.cursor.fetchall()

    def get_negative_sentences(self):
        request = "select * from CCALIDAD_PALABRA"
        self.cursor.execute(request)
        return self.cursor.fetchall()

    def get_grabaciones(self):
        requete = "select * from grabaciones"
        self.cursor.execute(requete)
        return self.cursor.fetchall()

    def get_grabacion_given_name(self, name: str):
        requete = "select * from grabaciones where nombre = ?"
        self.cursor.execute(requete, name)
        return self.cursor.fetchone()

    def get_calificacion_given_id(self, grabaciones_id):
        requete = f"select * from AUTOGENERATED_SCORES where id = ? "
        self.cursor.execute(requete, grabaciones_id)
        return self.cursor.fetchone()

    def get_autogenerated_scores(self):
        requete = "select * from AUTOGENERATED_SCORES"
        self.cursor.execute(requete)
        return self.cursor.fetchall()

    def add_grabaciones(self, id_grabacion, nombre, telefono, fecha, audio):
        requete = f"INSERT INTO GRABACIONES " \
                  f"(g_id, nombre, numero, fecha, mensaje) " \
                  f"VALUES" \
                  f" ({id_grabacion}, '{nombre}', '{telefono}', '{fecha}', '{audio}')"
        self.cursor.execute(requete)
        self.cursor.commit()

    def add_autogenerated_scores(self, id_grabacion: str, scores: dict):
        attributes = self.dichotomise_ticket_score(scores['ticket_score'])

        requete = f"INSERT INTO AUTOGENERATED_SCORES" \
                  f" VALUES " \
                  f"({id_grabacion}, {scores['total']}, {attributes['cedente']}, {attributes['cierre']}, {attributes['convenio']}, {attributes['grabacion']}, {attributes['identificacion']}, {attributes['motivo']}, {attributes['objecciones']}, {attributes['saludo']})"
        self.cursor.execute(requete)
        self.cursor.commit()

    def dichotomise_ticket_score(self, ticket_score: dict):
        attributes = {
                      "cedente": "cedente",
                      "cierre": "cierre",
                      "convenio": "convenio",
                      "grabacion": "grabacion",
                      "identificacion": "identificacion",
                      "motivo": "motivo",
                      "objecciones": "objecciones",
                      "saludo": "saludo"}

        self.cursor.execute("SELECT top 1 * FROM AUTOGENERATED_SCORES")
        for key in self.cursor.description:
            real_key = key[0]
            if real_key in ticket_score:
                attributes[real_key.lower()] = ticket_score[real_key]
            elif real_key.lower() in attributes:
                attributes[real_key.lower()] = 0
        return attributes

    def setup_cedente_general(self):
        self.cursor.execute(
            "INSERT INTO CEDENTE (nombre_ced) VALUES ('CEDENTE_GENERAL');"
        )
        serial_ced = self.get_serialced_from_cedente("CEDENTE_GENERAL")
        list_of_commands = [
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'CEDENTE','CEDENTE', 'EN REPRESENTACION', 'LE LLAMAMOS DE', 2, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'CIERRE','GRACIAS', 'QUE TENGA UN', 'HASTA LUEGO', 2, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'CONVENIO','PROXIMO ABONO', 'FECHA DE PAGO', 'CUANDO PAGARA', 2, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'GRABACION','GRABADA', 'LLAMADA ESTA SIENDO GRABADA', 'LLAMADA FUE GRABADA', 1, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'IDENTIFICACION','LE SALUDA DE', 'MI NOMBRE ES', 'LE ESTA HABLANDO', 1, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'MOTIVO','EL MOTIVO DE LA LLAMADA', 'EL MOTIVO DE MI LLAMADA', 'EL MOTIVO DE LA MISMA', 1, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'OBJECIONES','CONVENIO A', 'REESTRUCTURACION', 'CUOTA INICIAL', 1, 'ACTIVO', 'GENERAL');",
            f"INSERT INTO CCALIDAD_FRASE (serial_ced, etiqueta_ccf, frase_ccf, alternativaf1_ccf, alternativaf2_ccf, puntaje_ccf, tipo_ccf, observacion_ccf) VALUES ({serial_ced[0]}, 'SALUDO','BUENOS', 'BUENAS TARDES', 'BUENAS NOCHES', 1, 'ACTIVO', 'GENERAL');"
        ]
        print("Len List of commands", len(list_of_commands))
        for command in list_of_commands:
            self.cursor.execute(command)

    def check_if_exists(self, table_name) -> bool:
        try:
            requete = f"select top 1 * from {table_name}"
            self.cursor.execute(requete)

            return True

        except ProgrammingError:
            return False

    def create_tables(self):
        autogenerated_IA = self.check_if_exists("AUTOGENERATED_SCORES")
        grabaciones = self.check_if_exists("GRABACIONES")

        if not grabaciones:
            requete = "CREATE TABLE GRABACIONES (\
                id INT NOT NULL IDENTITY PRIMARY KEY,\
                g_id INT NOT NULL, \
                nombre VARCHAR(70), \
                numero VARCHAR(10), \
                fecha DATE, \
                mensaje VARCHAR(MAX)\
            )"

            self.cursor.execute(requete
            )

        if not autogenerated_IA:
            self.cursor.execute(
                "CREATE TABLE AUTOGENERATED_SCORES( \
                id INT NOT NULL, \
                TOTAL INT NOT NULL,\
                CEDENTE INT, \
                CIERRE INT, \
                CONVENIO INT, \
                GRABACION INT, \
                IDENTIFICACION INT, \
                MOTIVO INT, \
                OBJECCIONES INT, \
                SALUDO INT,\
                PRIMARY KEY(id), \
                CONSTRAINT fk_idscores_idgrabaciones FOREIGN KEY (id) REFERENCES GRABACIONES(id) \
                ON DELETE CASCADE \
                )")

        return not(autogenerated_IA and grabaciones)

    def test(self, y: str, m: str, d: str):

        requests = "select top 20 id_gestion, accion_ges, respuesta_ges, telefono_ges, fecha_ges, cedente, serial_ced " \
                   "from CEDENTE a inner join GESTIONES b  on a.nombre_ced=b.cedente " \
                   f"where tipo_ges = 1 and convert(date,fecha_ges,120)=convert(date,'{y}-{m}-{d}',120)"
        self.cursor.execute(requests)
        return self.cursor.fetchall()
